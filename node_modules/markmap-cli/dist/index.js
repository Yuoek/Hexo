/*! markmap-cli v0.13.5 | MIT License */
'use strict';

var fs = require('fs');
var commander = require('commander');
var open = require('open');
var markmapLib = require('markmap-lib');
var events = require('events');
var http = require('http');
var Koa = require('koa');
var chokidar = require('chokidar');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

var open__default = /*#__PURE__*/_interopDefaultLegacy(open);
var http__default = /*#__PURE__*/_interopDefaultLegacy(http);
var Koa__default = /*#__PURE__*/_interopDefaultLegacy(Koa);
var chokidar__default = /*#__PURE__*/_interopDefaultLegacy(chokidar);

const TOOLBAR_VERSION = "0.13.5";
const TOOLBAR_CSS = `npm/markmap-toolbar@${TOOLBAR_VERSION}/dist/style.min.css`;
const TOOLBAR_JS = `npm/markmap-toolbar@${TOOLBAR_VERSION}/dist/index.umd.min.js`;

const renderToolbar = () => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
};

function addToolbar(assets) {
  return {
    styles: [...(assets.styles || []), {
      type: 'stylesheet',
      data: {
        href: `https://cdn.jsdelivr.net/${TOOLBAR_CSS}`
      }
    }],
    scripts: [...(assets.scripts || []), {
      type: 'script',
      data: {
        src: `https://cdn.jsdelivr.net/${TOOLBAR_JS}`
      }
    }, {
      type: 'iife',
      data: {
        fn: r => {
          setTimeout(r);
        },
        getParams: () => [renderToolbar]
      }
    }]
  };
}
class Defer {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }

}

/* eslint-disable max-classes-per-file */

function consecutive(fn) {
  let promise;
  return () => {
    if (!promise) {
      promise = fn();
      promise.catch(() => {}).then(() => {
        promise = null;
      });
    }

    return promise;
  };
}

class BufferContentProvider {
  constructor() {
    this.deferredSet = new Set();
    this.events = new events.EventEmitter();
    this.ts = 0;
    this.events.on('content', () => {
      this.feed({
        ts: this.ts,
        content: this.content
      });
    });
    this.events.on('cursor', () => {
      this.feed({
        line: this.line
      });
    });
  }

  async getUpdate(ts, timeout = 10000) {
    const deferred = new Defer();
    this.deferredSet.add(deferred);
    setTimeout(() => {
      this.feed({}, deferred);
    }, timeout);

    if (ts < this.ts) {
      this.feed({
        ts: this.ts,
        content: this.content
      }, deferred);
    }

    return deferred.promise;
  }

  feed(data, deferred) {
    if (deferred) {
      deferred.resolve(data);
      this.deferredSet.delete(deferred);
    } else {
      for (const d of this.deferredSet) {
        d.resolve(data);
      }

      this.deferredSet.clear();
    }
  }

  setCursor(line) {
    this.line = line;
    this.events.emit('cursor');
  }

  setContent(content) {
    this.ts = Date.now();
    this.content = content;
    this.events.emit('content');
  }

  dispose() {}

}

class FileSystemProvider extends BufferContentProvider {
  constructor(fileName) {
    super();
    this.fileName = fileName;
    this.watcher = chokidar__default.watch(fileName).on('all', consecutive(() => this.update()));
  }

  async update() {
    const content = await fs.promises.readFile(this.fileName, 'utf8');
    this.setContent(content);
  }

  dispose() {
    super.dispose();
    this.watcher.close();
  }

}

function startServer(paddingBottom) {
  let ts = 0;
  const {
    mm,
    markmap
  } = window;
  refresh();

  function refresh() {
    fetch(`/data?ts=${ts}`).then(res => res.json()).then(res => {
      if (res.ts && res.ts > ts && res.result) {
        const {
          root,
          frontmatter
        } = res.result;
        mm.setOptions(markmap.deriveOptions(frontmatter == null ? void 0 : frontmatter.markmap));
        mm.setData(root);
        if (!ts) mm.fit();
        ts = res.ts;
      }

      setTimeout(refresh, 300);
    });
  }
}

function setUpServer(transformer, provider, options) {
  let assets = transformer.getAssets();
  if (options.toolbar) assets = addToolbar(assets);
  const html = `${markmapLib.fillTemplate(null, assets)}<script>(${startServer.toString()})(${options.toolbar ? 60 : 0})</script>`;
  const app = new Koa__default();
  app.use(async (ctx, next) => {
    if (ctx.path === '/') {
      ctx.body = html;
    } else if (ctx.path === '/data') {
      const update = await provider.getUpdate(ctx.query.ts);
      const result = update.content == null ? null : transformer.transform(update.content || '');
      ctx.body = {
        ts: update.ts,
        result,
        line: update.line
      };
    } else {
      await next();
    }
  });
  const handle = app.callback();
  const server = http__default.createServer(handle);
  server.listen(() => {
    const {
      port
    } = server.address();
    console.info(`Listening at http://localhost:${port}`);
    if (options.open) open__default(`http://localhost:${port}`);
  });
  let closing;
  return {
    provider,

    close() {
      if (!closing) {
        closing = new Promise((resolve, reject) => server.close(err => {
          if (err) reject(err);else resolve();
        }));
      }

      return closing;
    }

  };
}

async function develop(fileName, options) {
  const transformer = new markmapLib.Transformer();
  const provider = fileName ? new FileSystemProvider(fileName) : new BufferContentProvider();
  return setUpServer(transformer, provider, options);
}

async function createMarkmap(options) {
  const transformer = new markmapLib.Transformer();
  const {
    root,
    features,
    frontmatter
  } = transformer.transform(options.content || '');
  let assets = transformer.getUsedAssets(features);
  if (options.toolbar) assets = addToolbar(assets);
  const html = markmapLib.fillTemplate(root, assets, {
    jsonOptions: frontmatter == null ? void 0 : frontmatter.markmap
  });
  const output = options.output || 'markmap.html';
  await fs.promises.writeFile(output, html, 'utf8');
  if (options.open) open__default(output);
}
function main(version) {
  const program = new commander.Command();
  program.version(version).description('Create a markmap from a Markdown input file').arguments('<input>').option('--no-open', 'do not open the output file after generation').option('--no-toolbar', 'do not show toolbar').option('-o, --output <output>', 'specify filename of the output HTML').option('-w, --watch', 'watch the input file and update output on the fly, note that this feature is for development only').action(async (input, cmd) => {
    const content = await fs.promises.readFile(input, 'utf8');
    const output = cmd.output || `${input.replace(/\.\w*$/, '')}.html`;

    if (cmd.watch) {
      await develop(input, {
        open: cmd.open,
        toolbar: cmd.toolbar
      });
    } else {
      await createMarkmap({
        content,
        output,
        open: cmd.open,
        toolbar: cmd.toolbar
      });
    }
  });
  program.parse(process.argv);
}

exports.createMarkmap = createMarkmap;
exports.develop = develop;
exports.main = main;
for (var k in markmapLib) {
if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = markmapLib[k];
}
